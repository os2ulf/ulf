/**
 * @name Search node Angular library
 * @version v1.0.0-rc5
 * @link https://github.com/search-node/searchpt
 */

/**
 * @file
 * Defines the Angular JS application.
 */

// Define the angular applications.
angular.module('searchBoxApp', ['communicationService', 'searchAppConfig', 'angular-cache']);
angular.module('searchResultApp', ['communicationService', 'searchAppConfig']);

/**
 * When the document is ready bootstrap the two applications.
 */
angular.element(document).ready(function() {
  "use strict";

  // Bootstrap the search result area. This has to be booted first to ensure
  // that it's ready for events from the search box bootstrap process.
  var result = document.getElementById("searchResultApp");
  if (result) {
    angular.bootstrap(result, ['searchResultApp']);
  }

  // Bootstrap search box.
  var box = document.getElementById("searchBoxApp");
  if (box) {
    angular.bootstrap(box, ['searchBoxApp']);
  }
});

/**
 * @file
 * This is the main controller for the application.
 *
 * It controls the search box and filters.
 */

angular.module('searchBoxApp').controller('boxController', ['CONFIG', 'communicatorService', 'searchProxy', '$scope',
  function (CONFIG, communicatorService, searchProxy, $scope) {
    'use strict';

    // Set the filters to get the UI initials fast.
    $scope.filters = searchProxy.getRawFilters();

    // Set template to use.
    $scope.template = CONFIG.templates.box;

    // Init the query object.
    $scope.query = {
      'text': '',
      'filters': {}
    };

    // Check if the provider supports an pager.
    if (CONFIG.provider.hasOwnProperty('pager')) {
      // Add pager information to the search query.
      $scope.query.pager = angular.copy(CONFIG.provider.pager);
    }

    // Get filters based on search content (maybe slow).
    $scope.filters = searchProxy.getFilters().then(
      function (filters) {
        $scope.filters = filters;
      },
      function (reason) {
        console.error(reason);
      }
    );

    /**
     * @TODO: Missing description.
     */
    communicatorService.$on('pager', function (event, data) {
      $scope.query.pager = {
        'size': data.size,
        'page': data.page
      };
      search();
    });

    /**
     * @TODO: Missing description.
     */
    $scope.searchClicked = function searchClicked() {
      // Reset pager.
      if ($scope.query.hasOwnProperty('pager')) {
        $scope.query.pager = angular.copy(CONFIG.provider.pager);
      }

      search();
    };

    /**
     * Execute the search and emit the results.
     */
    function search() {
      searchProxy.search($scope.query).then(
        function (data) {
          // Updated filters.
          searchProxy.getFilters().then(
            function (filters) {
              $scope.filters = filters;
            },
            function (reason) {
              console.error(reason);
            }
          );

          // Send results.
          communicatorService.$emit('hits', {"hits" : data});
        },
        function (reason) {
          console.error(reason);
        }
      );
    }
  }
]);

/**
 * @file
 * This is the controller for the search result application.
 *
 * It simply updated the view when hits have been received.
 */

angular.module('searchResultApp').controller('resultController', ['CONFIG', 'communicatorService', '$scope',
  function (CONFIG, communicatorService, $scope) {
    'use strict';

    // Set template to use.
    $scope.template = CONFIG.templates.result;


    // Check if the provider supports an pager.
    if (CONFIG.provider.hasOwnProperty('pager')) {
      // Add pager information to the scope.
      $scope.pager = angular.copy(CONFIG.provider.pager);
    }

    /**
     * Update pager information.
     */
    $scope.search = function search() {
      communicatorService.$emit('pager', $scope.pager);
    };

    $scope.hits = [];
    communicatorService.$on('hits', function (event, data) {
      $scope.$apply(function() {
        $scope.hits = data.hits;
      });
    });

    communicatorService.$on('pager', function (event, data) {
      $scope.$apply(function() {
        $scope.pager = data;
      });
    });
  }
]);

/**
 * @file
 * Directive to capture key codes.
 *
 * @see http://codepen.io/TheLarkInn/blog/angularjs-directive-labs-ngenterkey.
 */
angular.module('searchBoxApp').directive('keyCode', function keyCode() {
  'use strict';

  return {
    restrict: 'A',
    link: function($scope, $element, $attrs) {
      $element.bind("keypress", function(event) {
        var keyCode = event.which || event.keyCode;

        if (keyCode === $attrs.code) {
          $scope.$apply(function() {
            $scope.$eval($attrs.keyCode, { $event: event });
          });
        }
      });
    }
  };
});
/**
 * @file
 * Paging directive.
 */

/**
 * Paging directive.
 */
angular.module('searchResultApp').directive('searchPager', ['CONFIG',
  function (CONFIG) {
    'use strict';

    return {
      restrict: 'E',
      replace: true,
      scope: true,
      controller: ["$scope", function ($scope) {

        /**
         * Click handler to change page.
         *
         * @param page
         */
        $scope.changePage = function changePage(page) {
          $scope.pager.page = page;
          $scope.search();
        };

        $scope.prevPage = function prevPage() {
          if ($scope.pager.page > 0) {
            $scope.pager.page--;
            $scope.search();
          }
        };

        $scope.nextPage = function nextPage() {
          if ($scope.pager.page < $scope.pager.max - 1) {
            $scope.pager.page++;
            $scope.search();
          }
        };

        // Keep an any on changes in number of hits.
        $scope.$watch('hits', function (hits) {
          var hits = $scope.hits.hits;
          var pages = [];
          $scope.pager.max = 0;
          if (hits > $scope.pager.size) {
            $scope.pager.max = Math.ceil(hits / $scope.pager.size);
            for (var i = 0; i < $scope.pager.max; i++) {
              pages.push(i);
            }
          }
          $scope.pager.pages = pages;
        });
      }],
      templateUrl: CONFIG.templates.pager
    };
  }
]);

/**
 * @file
 * Dummy search provider that reads the search results from a JSON file.
 */

/**
 * Search provider for JSON files.
 */
angular.module('searchBoxApp').service('jsonProvider', ['CONFIG', '$q', '$http',
  function (CONFIG, $q, $http) {
    'use strict';

    // Load JSON file based on configuration.
    var data = [];
    $http.get(CONFIG.provider.data)
      .then(function(res){
        data = res.data;
      });

    /**
     * The filters available.
     *
     * @returns json array.
     */
    this.getFilters = function getFilters() {
      return {
        'tags': {
          'name': 'Tags',
          'type': 'and',
          'items': [
            {
              'name': 'Angular',
              'value': 'angular'
            },
            {
              'name': 'Developer',
              'value': 'developer'
            },
            {
              'name': 'Javascript',
              'value': 'javascript'
            },
            {
              'name': 'Chrome',
              'value': 'chrome'
            }
          ]
        },
        'levels':{
          'name': 'Levels (or)',
          'type': 'or',
          'items': [
            {
              'name': 'First',
              'value': 1
            },
            {
              'name': 'Second',
              'value': 2
            },
            {
              'name': 'Third',
              'value': 3
            },
            {
              'name': 'Fourth',
              'value': 4
            }
          ]
        }
      };
    };

    /**
     * Search function to query the json data.
     *
     * @param query
     *   The query parameters to search
     *
     * @returns {Array}
     *   The hits found.
     */
    this.search = function query(query) {
      var self = this;
      var hits = angular.copy(data);

      var deferred = $q.defer();

      // Search title.
      if (query.text !== '') {
        hits = JSON.search(data, '//*[contains(title, "' + query.text + '")]');
      }

      // Search filters.
      angular.forEach(query.filters, function (filter, name) {
        // Get search type 'or' or 'and'.
        var type = self.getFilters();
        var xp = false;

        angular.forEach(filter, function (enabled, value) {
          if (enabled) {
            if (type === 'or') {
              // Or type search needs to build and xpath expression for all items
              // in the filter.
              if (xp === false) {
                xp = '//*[' + name + '="' + value + '"]';
              }
              else {
                xp += '|//*[' + name + '="' + value + '"]';
              }
            }
            else {
              // "And" type search simply limites the results.
              hits = JSON.search(hits, '//*[' + name + '="' + value + '"]');
            }
          }
        });

        // After all other search apply the "or" search expression.
        if (type === 'or' && xp) {
          hits = JSON.search(hits, xp);
        }
      });

      // This may seem strange, but it's to keep up with the way search node
      // works. So it makes sens to return an resolve the promise just after
      // each other.
      deferred.resolve({
        'hits': hits.length,
        'results': hits
      });

      return deferred.promise;
    };
  }
]);
/**
 * @file
 * Search provider for the search node framework.
 */

angular.module('searchBoxApp').service('searchNodeProvider', ['CONFIG', '$q', '$http', 'CacheFactory',
  function (CONFIG, $q, $http, CacheFactory) {
    'use strict';

    // Configuration options.
    var configuration = CONFIG.provider;

    // Search node connection handling.
    var socket;
    var loadedSocketIo = false;
    var token = null;

    // Create cache object.
    var searchCache = new CacheFactory('searchCache', {
      maxAge: configuration.cacheExpire * 1000,
      deleteOnExpire: 'passive',
      storageMode: 'localStorage'
    });

    // Holder for the latest search query filters.
    var currentFilters;

    /**
     * Load the socket.io library provided by the search node.
     *
     * @return {promise}
     *   An promise is return that will be resolved on library loaded.
     */
    function loadSocketIoScript() {
      var deferred = $q.defer();

      // Check if it have been loaded.
      if (!loadedSocketIo) {
        // Create script element.
        var script = document.createElement("script");
        script.type = "text/javascript";

        // Add event handlers for the library loaded.
        if (script.readyState) {
          // Handle internet explore.
          script.onreadystatechange = function () {
            if (script.readyState === "loaded" || script.readyState === "complete") {
              script.onreadystatechange = null;
              loadedSocketIo = true;
              deferred.resolve();
            }
          };
        } else {
          // All other browsers.
          script.onload = function () {
            loadedSocketIo = true;
            deferred.resolve();
          };
        }

        // Add the script and add it to the dom to load it.
        script.src = configuration.host + "/socket.io/socket.io.js";
        document.getElementsByTagName("head")[0].appendChild(script);
      }
      else {
        deferred.resolve();
      }

      return deferred.promise;
    }

    /**
     * Connect to the web-socket.
     *
     * @param deferred
     *   The is a deferred object that should be resolved on connection.
     */
    function getSocket(deferred) {
      // Load the socket library.
      loadSocketIoScript().then(function () {
        // Get connected to the server.
        socket = io.connect(configuration.host, {
          'query': 'token=' + token,
          'force new connection': true,
          'max reconnection attempts': Infinity
        });

        // Handle error events.
        socket.on('error', function (reason) {
          console.error(reason, 'Search socket error.');
          deferred.reject(reason);
        });

        socket.on('connect', function () {
          deferred.resolve('Connected to the server.');
        });

        // Handle disconnect event (fires when disconnected or connection fails).
        socket.on('disconnect', function (reason) {
          // @todo: re-connection is automatically handled by socket.io library,
          // but we might need to stop sending request until reconnection or the
          // request will be queued and send all at once... which could give some
          // strange side effects in the application if not handled.
        });
      });
    }

    /**
     * Create the connection to the server.
     *
     * @return {promise}
     *   An promise is return that will be resolved on connection.
     */
    function connect() {
      // Try to connect to the server if not already connected.
      var deferred = $q.defer();

      if (socket === undefined) {
        if (token !== null) {
          getSocket(deferred);
        }
        else {
          $http.get(configuration.auth)
            .success(function (data) {
              token = data.token;
              getSocket(deferred);
            })
            .error(function (data, status) {
              console.error(data, 'Authentication (search) to search node failed (' + status + ')');
              deferred.reject(status);
            });
        }
      }
      else {
        deferred.resolve('Connected to the server.');
      }

      return deferred.promise;
    }

    /**
     * Builds aggregation query based on filters.
     *
     * @param filters
     */
    function buildAggregationQuery(filters) {
      // Basic aggregation query.
      var query = {
        'aggs': {}
      };

      // Extend query with filter fields.
      for (var i = 0; i < filters.length; i++) {
        var filter = filters[i];
        query.aggs[filter.name] = {
          "terms": {
            'field': filter.field
          }
        };
      }

      return query;
    }

    /**
     * Parse filter configuration and search aggregations.
     *
     * Merge result with filters configuration as not all terms may have
     * been used in the content and then not in found in the search
     * node.
     *
     * @param aggs
     *
     * @returns {{}}
     */
    function parseFilters(aggs) {
      var results = {};
      if (CONFIG.provider.hasOwnProperty('filters')) {
        var filters = CONFIG.provider.filters;

        for (var i = 0; i < filters.length; i++) {
          var filter = angular.copy(filters[i]);

          // Set basic filter with counts.
          results[filter.field] = {
            'name': filter.name,
            'items': filter.terms
          };

          // Run through counts and update the filter.
          for (var j = 0; j < aggs[filter.name].buckets.length; j++) {
            var bucket = aggs[filter.name].buckets[j];
            results[filter.field].items[bucket.key].count = Number(bucket.doc_count);
          }
        }
      }

      return results;
    }
    /**
     * Get the list of available filters not parsed with search results.
     *
     * @return array
     *  The filters from the confiuration.
     */
    this.getRawFilters = function getRawFilters() {
      var result = {};

      if (CONFIG.provider.hasOwnProperty('filters')) {
        var filters = CONFIG.provider.filters;
        for (var i = 0; i < filters.length; i++) {

          // Set basic filter with counts.
          result[filters[i].field] = {
            'name': filters[i].name,
            'items': filters[i].terms
          };
        }
      }

      return result;
    }

    /**
     * Get the list of available filters.
     *
     * @PLAN:
     *   Check if latest search return aggregations, if not use the configuration
     *   to search the get all available aggregations.
     *
     *   Merge it with configuration to ensure that all possible filters are
     *   displayed with count.
     */
    this.getFilters = function getFilters() {
      var deferred = $q.defer();

      // Get filters from configuration.
      if (CONFIG.provider.hasOwnProperty('filters')) {
        var filters = CONFIG.provider.filters;

        // If no search have been executed yet, load the default filters across
        // all indexed data.
        if (currentFilters === undefined) {
          // Check if filters are cached.
          var cachedFilters = searchCache.get('filters');
          if (cachedFilters !== undefined) {
            // Store current filters.
            currentFilters = cachedFilters;

            // Return the result.
            deferred.resolve(angular.copy(currentFilters));
          }
          else {
            // Get the query.
            var query = buildAggregationQuery(filters);

            // Send the request to search node.
            connect().then(function () {
              socket.emit('count', query);
              socket.once('counts', function (counts) {
                var results = parseFilters(counts);

                // Store initials filters in cache.
                searchCache.put('filters', results);

                // Store current filters.
                currentFilters = results;

                // Return the result.
                deferred.resolve(results);
              });

              // Catch search errors.
              socket.once('searchError', function (error) {
                console.error('Search error', error.message);
                deferred.reject(error.message);
              });
            });
          }
        }
        else {
          // Return the result.
          deferred.resolve(angular.copy(currentFilters));
        }
      }
      else {
        deferred.resolve({});
      }

      return deferred.promise;
    };

    /**
     * Execute search query.
     *
     * @param searchQuery
     * @returns {*}
     */
    this.search = function search(searchQuery) {
      var deferred = $q.defer();

      // Build default match all search query.
      var query = {
        "index": configuration.index,
        "query": {
          "filtered": {
            "query" : {
              "match_all": {}
            }
          }
        }
      };

      // Text given build field search query.
      // The analyser ensures that we match the who text string sent not part
      // of.
      if (searchQuery.text !== undefined && searchQuery.text !== '') {
        query.query.filtered.query = {
          "multi_match": {
            "query": searchQuery.text,
            "fields": configuration.fields,
            "analyzer": 'string_search'
          }
        };
      }

      // Add filter.
      if (searchQuery.hasOwnProperty('filters')) {
        var filters = angular.copy(searchQuery.filters);

        // Build query filter.
        var queryFilter =  {
          "bool": {
            "must": [ ]
          }
        };

        // Load over all filters.
        for (var field in filters) {
          /**
           * @TODO: Needs to get information from configuration about execution
           *        type?
           */
          var terms = {
            "execution" : "and"
          };

          terms[field] = [];
          for (var term in filters[field]) {
            // Check the the term is "true" selected.
            if (filters[field][term]) {
              terms[field].push(term);
            }
          }

          /**
           * @TODO: Handled more than one filter
           */
          if (terms[field].length) {
            queryFilter.bool.must.push({ "terms": angular.copy(terms) });
          }
        }

        // Add the query filter if filled out.
        if (queryFilter.bool.must.length) {
          query.query.filtered.filter = queryFilter;
        }
      }

      // Add pager to the query.
      if (searchQuery.hasOwnProperty('pager')) {
        query.size = searchQuery.pager.size;
        query.from = searchQuery.pager.page * searchQuery.pager.size;
      }

      // Check if aggregations/filters counts should be used.
      if (CONFIG.provider.hasOwnProperty('filters')) {
        // Get the query.
        var aggs = buildAggregationQuery(CONFIG.provider.filters);
        angular.extend(query, aggs);
      }

      // Create cache key based on the finale search query.
      var cid = CryptoJS.MD5(JSON.stringify(query)).toString();

      // Check cache for hits.
      var hits = searchCache.get(cid);
      if (hits !== undefined) {
        // Update filters cache.
        if (hits.hasOwnProperty('aggs')) {
          currentFilters = parseFilters(angular.copy(hits.aggs));
        }

        deferred.resolve(hits);
      }
      else {
        connect().then(function () {
          socket.emit('search', query);
          socket.once('result', function (hits) {

            // Update cache filters cache.
            if (hits.hasOwnProperty('aggs')) {
              // Store current filters.
              currentFilters = parseFilters(angular.copy(hits.aggs));
            }

            // Save hits in cache.
            searchCache.put(cid, hits);

            deferred.resolve(hits);
          });

          // Catch search errors.
          socket.once('searchError', function (error) {
            console.error('Search error', error.message);
            deferred.reject(error.message);
          });
        });
      }

      return deferred.promise;
    };
  }
]);

/**
 * @file
 * Service to communication between search box and search result applications.
 */

angular.module('communicationService', [])
  .service('communicatorService', ["$rootScope", "$window", function($rootScope, $window){
    'use strict';

    // Store rootScopes for each service user.
    $window.rootScopes = $window.rootScopes || [];
    $window.rootScopes.push($rootScope);

    /**
     * Wrapper for emitting events to all root scopes.
     *
     * @param name
     *   Event name
     * @param args
     *   Event arguments.
     */
    this.$emit = function emit(name, args) {
      angular.forEach($window.rootScopes, function(scope) {
        scope.$emit(name, args);
      });
    };

    /**
     * Wrapper to attach event listeners to the current root scope.
     *
     * @param name
     *   Event name.
     * @param listener
     *   The listener to call on event.
     */
    this.$on = function on(name, listener) {
      $rootScope.$on(name, function (event, message) {
        listener.apply($rootScope, [event, message]);
      });
    };
  }]);
/**
 * @file
 * Search proxy.
 *
 * Allows the framework to use different search back-ends based on
 * configuration settings.
 */

/**
 * Search proxy is used to send search requests to the configured provide.
 */
angular.module('searchBoxApp').service('searchProxy', ['CONFIG', 'communicatorService', '$injector',
  function (CONFIG, communicatorService, $injector) {
    'use strict';

    // Load provider based on configuration.
    var provider = $injector.get(CONFIG.provider.service);

    /**
     * Search the provider loaded.
     *
     * This simply forwards the search request to the provider loaded.
     *
     * @param query
     *   The search query.
     *
     * @returns {Number|*|Object}
     *   The search result.
     */
    this.search = function search(query) {
      return provider.search(query);
    };

    /**
     * Get filters provided by configuraion.
     *
     * @returns json
     */
    this.getRawFilters = function getRawFilters() {
      return provider.getRawFilters();
    };

    /**
     * Get filters provided by search engine used.
     *
     * @returns json
     */
    this.getFilters = function getFilters() {
      return provider.getFilters();
    };
  }
]);

//# sourceMappingURL=/maps/search.js.map