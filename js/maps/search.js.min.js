{"version":3,"sources":["search.js","controllers/search_box.js","controllers/search_result.js","directive/keyCodeDirective.js","directive/pagerDirective.js","providers/json.js","providers/search_node.js","services/communicator.js","services/search_proxy.js"],"names":["angular","module","element","document","ready","result","getElementById","bootstrap","box","controller","CONFIG","communicatorService","searchProxy","$scope","search","query","then","data","getFilters","filters","reason","console","error","$emit","hits","template","templates","text","provider","hasOwnProperty","pager","copy","$on","event","size","page","searchClicked","$apply","directive","restrict","link","$element","$attrs","bind","keyCode","which","code","$eval","$event","replace","scope","changePage","prevPage","nextPage","max","$watch","pages","Math","ceil","i","push","templateUrl","service","$q","$http","get","res","this","tags","name","type","items","value","levels","self","deferred","defer","JSON","forEach","filter","xp","enabled","resolve","length","results","promise","CacheFactory","loadSocketIoScript","loadedSocketIo","script","createElement","readyState","onreadystatechange","onload","src","configuration","host","getElementsByTagName","appendChild","getSocket","socket","io","connect","token","force new connection","max reconnection attempts","Infinity","on","reject","undefined","auth","success","status","buildAggregationQuery","aggs","terms","field","parseFilters","j","buckets","bucket","key","count","Number","doc_count","currentFilters","searchCache","maxAge","cacheExpire","deleteOnExpire","storageMode","cachedFilters","emit","once","counts","put","message","searchQuery","index","filtered","match_all","multi_match","fields","analyzer","queryFilter","bool","must","execution","term","from","extend","cid","CryptoJS","MD5","stringify","toString","$rootScope","$window","rootScopes","args","listener","apply","$injector"],"mappings":"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","file":"search.js","sourcesContent":["\n/**\n * @file\n * Defines the Angular JS application.\n */\n\n// Define the angular applications.\nangular.module('searchBoxApp', ['communicationService', 'searchAppConfig', 'angular-cache']);\nangular.module('searchResultApp', ['communicationService', 'searchAppConfig']);\n\n/**\n * When the document is ready bootstrap the two applications.\n */\nangular.element(document).ready(function() {\n  \"use strict\";\n\n  // Bootstrap the search result area. This has to be booted first to ensure\n  // that it's ready for events from the search box bootstrap process.\n  var result = document.getElementById(\"searchResultApp\");\n  if (result) {\n    angular.bootstrap(result, ['searchResultApp']);\n  }\n\n  // Bootstrap search box.\n  var box = document.getElementById(\"searchBoxApp\");\n  if (box) {\n    angular.bootstrap(box, ['searchBoxApp']);\n  }\n});","/**\n * @file\n * This is the main controller for the application.\n *\n * It controls the search box and filters.\n */\n\nangular.module('searchBoxApp').controller('boxController', ['CONFIG', 'communicatorService', 'searchProxy', '$scope',\n  function (CONFIG, communicatorService, searchProxy, $scope) {\n    'use strict';\n\n    // Set template to use.\n    $scope.template = CONFIG.templates.box;\n\n    // Init the query object.\n    $scope.query = {\n      'text': '',\n      'filters': {}\n    };\n\n    // Check if the provider supports an pager.\n    if (CONFIG.provider.hasOwnProperty('pager')) {\n      // Add pager information to the search query.\n      $scope.query.pager = angular.copy(CONFIG.provider.pager);\n    }\n\n    // Check if filters are defined by the provider.\n    searchProxy.getFilters().then(\n      function (filters) {\n        $scope.filters = filters;\n      },\n      function (reason) {\n        console.error(reason);\n      }\n    );\n\n    /**\n     * @TODO: Missing description.\n     */\n    communicatorService.$on('pager', function (event, data) {\n      $scope.query.pager = {\n        'size': data.size,\n        'page': data.page\n      };\n      search();\n    });\n\n    /**\n     * @TODO: Missing description.\n     */\n    $scope.searchClicked = function searchClicked() {\n      // Reset pager.\n      if ($scope.query.hasOwnProperty('pager')) {\n        $scope.query.pager = angular.copy(CONFIG.provider.pager);\n      }\n\n      search();\n    };\n\n    /**\n     * Execute the search and emit the results.\n     */\n    function search() {\n      searchProxy.search($scope.query).then(\n        function (data) {\n          // Updated filters.\n          searchProxy.getFilters().then(\n            function (filters) {\n              $scope.filters = filters;\n            },\n            function (reason) {\n              console.error(reason);\n            }\n          );\n\n          // Send results.\n          communicatorService.$emit('hits', {\"hits\" : data});\n        },\n        function (reason) {\n          console.error(reason);\n        }\n      );\n    }\n  }\n]);\n","/**\n * @file\n * This is the controller for the search result application.\n *\n * It simply updated the view when hits have been received.\n */\n\nangular.module('searchResultApp').controller('resultController', ['CONFIG', 'communicatorService', '$scope',\n  function (CONFIG, communicatorService, $scope) {\n    'use strict';\n\n    // Set template to use.\n    $scope.template = CONFIG.templates.result;\n\n\n    // Check if the provider supports an pager.\n    if (CONFIG.provider.hasOwnProperty('pager')) {\n      // Add pager information to the scope.\n      $scope.pager = angular.copy(CONFIG.provider.pager);\n    }\n\n    /**\n     * Update pager information.\n     */\n    $scope.search = function search() {\n      communicatorService.$emit('pager', $scope.pager);\n    };\n\n    $scope.hits = [];\n    communicatorService.$on('hits', function (event, data) {\n      $scope.$apply(function() {\n        $scope.hits = data.hits;\n      });\n    });\n\n    communicatorService.$on('pager', function (event, data) {\n      $scope.$apply(function() {\n        $scope.pager = data;\n      });\n    });\n  }\n]);","/**\n * @file\n * Directive to capture key codes.\n *\n * @see http://codepen.io/TheLarkInn/blog/angularjs-directive-labs-ngenterkey.\n */\nangular.module('searchBoxApp').directive('keyCode', function keyCode() {\n  'use strict';\n\n  return {\n    restrict: 'A',\n    link: function($scope, $element, $attrs) {\n      $element.bind(\"keypress\", function(event) {\n        var keyCode = event.which || event.keyCode;\n\n        if (keyCode === $attrs.code) {\n          $scope.$apply(function() {\n            $scope.$eval($attrs.keyCode, { $event: event });\n          });\n        }\n      });\n    }\n  };\n});","/**\n * @file\n * Paging directive.\n */\n\n/**\n * Paging directive.\n */\nangular.module('searchResultApp').directive('searchPager', [\n  function () {\n    'use strict';\n\n    return {\n      restrict: 'E',\n      replace: true,\n      scope: true,\n      controller: function ($scope) {\n\n        /**\n         * Click handler to change page.\n         *\n         * @param page\n         */\n        $scope.changePage = function changePage(page) {\n          $scope.pager.page = page;\n          $scope.search();\n        };\n\n        $scope.prevPage = function prevPage() {\n          if ($scope.pager.page > 0) {\n            $scope.pager.page--;\n            $scope.search();\n          }\n        };\n\n        $scope.nextPage = function nextPage() {\n          if ($scope.pager.page < $scope.pager.max - 1) {\n            $scope.pager.page++;\n            $scope.search();\n          }\n        };\n\n        // Keep an any on changes in number of hits.\n        $scope.$watch('hits', function (hits) {\n          var hits = $scope.hits.hits;\n          var pages = [];\n          $scope.pager.max = 0;\n          if (hits > $scope.pager.size) {\n            $scope.pager.max = Math.ceil(hits / $scope.pager.size);\n            for (var i = 0; i < $scope.pager.max; i++) {\n              pages.push(i);\n            }\n          }\n          $scope.pager.pages = pages;\n        });\n      },\n      templateUrl: '/js/directive/pager-directive.html'\n    };\n  }\n]);\n\n","/**\n * @file\n * Dummy search provider that reads the search results from a JSON file.\n */\n\n/**\n * Search provider for JSON files.\n */\nangular.module('searchBoxApp').service('jsonProvider', ['CONFIG', '$q', '$http',\n  function (CONFIG, $q, $http) {\n    'use strict';\n\n    // Load JSON file based on configuration.\n    var data = [];\n    $http.get(CONFIG.provider.data)\n      .then(function(res){\n        data = res.data;\n      });\n\n    /**\n     * The filters available.\n     *\n     * @returns json array.\n     */\n    this.getFilters = function getFilters() {\n      return {\n        'tags': {\n          'name': 'Tags',\n          'type': 'and',\n          'items': [\n            {\n              'name': 'Angular',\n              'value': 'angular'\n            },\n            {\n              'name': 'Developer',\n              'value': 'developer'\n            },\n            {\n              'name': 'Javascript',\n              'value': 'javascript'\n            },\n            {\n              'name': 'Chrome',\n              'value': 'chrome'\n            }\n          ]\n        },\n        'levels':{\n          'name': 'Levels (or)',\n          'type': 'or',\n          'items': [\n            {\n              'name': 'First',\n              'value': 1\n            },\n            {\n              'name': 'Second',\n              'value': 2\n            },\n            {\n              'name': 'Third',\n              'value': 3\n            },\n            {\n              'name': 'Fourth',\n              'value': 4\n            }\n          ]\n        }\n      };\n    };\n\n    /**\n     * Search function to query the json data.\n     *\n     * @param query\n     *   The query parameters to search\n     *\n     * @returns {Array}\n     *   The hits found.\n     */\n    this.search = function query(query) {\n      var self = this;\n      var hits = angular.copy(data);\n\n      var deferred = $q.defer();\n\n      // Search title.\n      if (query.text !== '') {\n        hits = JSON.search(data, '//*[contains(title, \"' + query.text + '\")]');\n      }\n\n      // Search filters.\n      angular.forEach(query.filters, function (filter, name) {\n        // Get search type 'or' or 'and'.\n        var type = self.getFilters();\n        var xp = false;\n\n        angular.forEach(filter, function (enabled, value) {\n          if (enabled) {\n            if (type === 'or') {\n              // Or type search needs to build and xpath expression for all items\n              // in the filter.\n              if (xp === false) {\n                xp = '//*[' + name + '=\"' + value + '\"]';\n              }\n              else {\n                xp += '|//*[' + name + '=\"' + value + '\"]';\n              }\n            }\n            else {\n              // \"And\" type search simply limites the results.\n              hits = JSON.search(hits, '//*[' + name + '=\"' + value + '\"]');\n            }\n          }\n        });\n\n        // After all other search apply the \"or\" search expression.\n        if (type === 'or' && xp) {\n          hits = JSON.search(hits, xp);\n        }\n      });\n\n      // This may seem strange, but it's to keep up with the way search node\n      // works. So it makes sens to return an resolve the promise just after\n      // each other.\n      deferred.resolve({\n        'hits': hits.length,\n        'results': hits\n      });\n\n      return deferred.promise;\n    };\n  }\n]);","/**\n * @file\n * Search provider for the search node framework.\n */\n\n\n\nangular.module('searchBoxApp').service('searchNodeProvider', ['CONFIG', '$q', '$http', 'CacheFactory',\n  function (CONFIG, $q, $http, CacheFactory) {\n    'use strict';\n\n    // Configuration options.\n    var configuration = CONFIG.provider;\n\n    // Search node connection handling.\n    var socket;\n    var loadedSocketIo = false;\n    var token = null;\n\n    // Create cache object.\n    var searchCache = new CacheFactory('searchCache', {\n      maxAge: configuration.cacheExpire * 1000,\n      deleteOnExpire: 'passive',\n      storageMode: 'localStorage'\n    });\n\n    // Holder for the latest search query filters.\n    var currentFilters;\n\n    /**\n     * Load the socket.io library provided by the search node.\n     *\n     * @return {promise}\n     *   An promise is return that will be resolved on library loaded.\n     */\n    function loadSocketIoScript() {\n      var deferred = $q.defer();\n\n      // Check if it have been loaded.\n      if (!loadedSocketIo) {\n        // Create script element.\n        var script = document.createElement(\"script\");\n        script.type = \"text/javascript\";\n\n        // Add event handlers for the library loaded.\n        if (script.readyState) {\n          // Handle internet explore.\n          script.onreadystatechange = function () {\n            if (script.readyState === \"loaded\" || script.readyState === \"complete\") {\n              script.onreadystatechange = null;\n              loadedSocketIo = true;\n              deferred.resolve();\n            }\n          };\n        } else {\n          // All other browsers.\n          script.onload = function () {\n            loadedSocketIo = true;\n            deferred.resolve();\n          };\n        }\n\n        // Add the script and add it to the dom to load it.\n        script.src = configuration.host + \"/socket.io/socket.io.js\";\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n      }\n      else {\n        deferred.resolve();\n      }\n\n      return deferred.promise;\n    }\n\n    /**\n     * Connect to the web-socket.\n     *\n     * @param deferred\n     *   The is a deferred object that should be resolved on connection.\n     */\n    function getSocket(deferred) {\n      // Load the socket library.\n      loadSocketIoScript().then(function () {\n        // Get connected to the server.\n        socket = io.connect(configuration.host, {\n          'query': 'token=' + token,\n          'force new connection': true,\n          'max reconnection attempts': Infinity\n        });\n\n        // Handle error events.\n        socket.on('error', function (reason) {\n          console.error(reason, 'Search socket error.');\n          deferred.reject(reason);\n        });\n\n        socket.on('connect', function () {\n          deferred.resolve('Connected to the server.');\n        });\n\n        // Handle disconnect event (fires when disconnected or connection fails).\n        socket.on('disconnect', function (reason) {\n          // @todo: re-connection is automatically handled by socket.io library,\n          // but we might need to stop sending request until reconnection or the\n          // request will be queued and send all at once... which could give some\n          // strange side effects in the application if not handled.\n        });\n      });\n    }\n\n    /**\n     * Create the connection to the server.\n     *\n     * @return {promise}\n     *   An promise is return that will be resolved on connection.\n     */\n    function connect() {\n      // Try to connect to the server if not already connected.\n      var deferred = $q.defer();\n\n      if (socket === undefined) {\n        if (token !== null) {\n          getSocket(deferred);\n        }\n        else {\n          $http.get(configuration.auth)\n            .success(function (data) {\n              token = data.token;\n              getSocket(deferred);\n            })\n            .error(function (data, status) {\n              console.error(data, 'Authentication (search) to search node failed (' + status + ')');\n              deferred.reject(status);\n            });\n        }\n      }\n      else {\n        deferred.resolve('Connected to the server.');\n      }\n\n      return deferred.promise;\n    }\n\n    /**\n     * Builds aggregation query based on filters.\n     *\n     * @param filters\n     */\n    function buildAggregationQuery(filters) {\n      // Basic aggregation query.\n      var query = {\n        'aggs': {}\n      };\n\n      // Extend query with filter fields.\n      for (var i = 0; i < filters.length; i++) {\n        var filter = filters[i];\n        query.aggs[filter.name] = {\n          \"terms\": {\n            'field': filter.field\n          }\n        };\n      }\n\n      return query;\n    }\n\n    /**\n     * Parse filter configuration and search aggregations.\n     *\n     * Merge result with filters configuration as not all terms may have\n     * been used in the content and then not in found in the search\n     * node.\n     *\n     * @param aggs\n     *\n     * @returns {{}}\n     */\n    function parseFilters(aggs) {\n      var results = {};\n      var filters = CONFIG.provider.filters;\n\n      for (var i = 0; i < filters.length; i++) {\n        var filter = angular.copy(filters[i]);\n\n        // Set basic filter with counts.\n        results[filter.field] = {\n          'name': filter.name,\n          'items': filter.terms\n        };\n\n        // Run through counts and update the filter.\n        for (var j = 0; j < aggs[filter.name].buckets.length; j++) {\n          var bucket = aggs[filter.name].buckets[j];\n          results[filter.field].items[bucket.key].count = Number(bucket.doc_count);\n        }\n      }\n\n      return results;\n    }\n\n    /**\n     * Get the list of available filters.\n     *\n     * @PLAN:\n     *   Check if latest search return aggregations, if not use the configuration\n     *   to search the get all available aggregations.\n     *\n     *   Merge it with configuration to ensure that all possible filters are\n     *   displayed with count.\n     */\n    this.getFilters = function getFilters() {\n      var deferred = $q.defer();\n\n      // Get filters from configuration.\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        var filters = CONFIG.provider.filters;\n\n        // If no search have been executed yet, load the default filters across\n        // all indexed data.\n        if (currentFilters === undefined) {\n          // Check if filters are cached.\n          var cachedFilters = searchCache.get('filters');\n          if (cachedFilters !== undefined) {\n            // Store current filters.\n            currentFilters = cachedFilters;\n\n            // Return the result.\n            deferred.resolve(angular.copy(currentFilters));\n          }\n          else {\n            // Get the query.\n            var query = buildAggregationQuery(filters);\n\n            // Send the request to search node.\n            connect().then(function () {\n              socket.emit('count', query);\n              socket.once('counts', function (counts) {\n                var results = parseFilters(counts);\n\n                // Store initials filters in cache.\n                searchCache.put('filters', results);\n\n                // Store current filters.\n                currentFilters = results;\n\n                // Return the result.\n                deferred.resolve(results);\n              });\n\n              // Catch search errors.\n              socket.once('searchError', function (error) {\n                console.error('Search error', error.message);\n                deferred.reject(error.message);\n              });\n            });\n          }\n        }\n        else {\n          // Return the result.\n          deferred.resolve(angular.copy(currentFilters));\n        }\n      }\n      else {\n        deferred.resolve({});\n      }\n\n      return deferred.promise;\n    };\n\n    /**\n     * Execute search query.\n     *\n     * @param searchQuery\n     * @returns {*}\n     */\n    this.search = function search(searchQuery) {\n      var deferred = $q.defer();\n\n      // Build default match all search query.\n      var query = {\n        \"index\": configuration.index,\n        \"query\": {\n          \"filtered\": {\n            \"query\" : {\n              \"match_all\": {}\n            }\n          }\n        }\n      };\n\n      // Text given build field search query.\n      // The analyser ensures that we match the who text string sent not part\n      // of.\n      if (searchQuery.text !== undefined && searchQuery.text !== '') {\n        query.query.filtered.query = {\n          \"multi_match\": {\n            \"query\": searchQuery.text,\n            \"fields\": configuration.fields,\n            \"analyzer\": 'string_search'\n          }\n        };\n      }\n\n      // Add filter.\n      if (searchQuery.hasOwnProperty('filters')) {\n        var filters = angular.copy(searchQuery.filters);\n\n        // Build query filter.\n        var queryFilter =  {\n          \"bool\": {\n            \"must\": [ ]\n          }\n        };\n\n        // Load over all filters.\n        for (var field in filters) {\n          /**\n           * @TODO: Needs to get information from configuration about execution\n           *        type?\n           */\n          var terms = {\n            \"execution\" : \"and\"\n          };\n\n          terms[field] = [];\n          for (var term in filters[field]) {\n            // Check the the term is \"true\" selected.\n            if (filters[field][term]) {\n              terms[field].push(term);\n            }\n          }\n\n          /**\n           * @TODO: Handled more than one filter\n           */\n          if (terms[field].length) {\n            queryFilter.bool.must.push({ \"terms\": angular.copy(terms) });\n          }\n        }\n\n        // Add the query filter if filled out.\n        if (queryFilter.bool.must.length) {\n          query.query.filtered.filter = queryFilter;\n        }\n      }\n\n      // Add pager to the query.\n      if (searchQuery.hasOwnProperty('pager')) {\n        query.size = searchQuery.pager.size;\n        query.from = searchQuery.pager.page * searchQuery.pager.size;\n      }\n\n      // Check if aggregations/filters counts should be used.\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        // Get the query.\n        var aggs = buildAggregationQuery(CONFIG.provider.filters);\n        angular.extend(query, aggs);\n      }\n\n      // Create cache key based on the finale search query.\n      var cid = CryptoJS.MD5(JSON.stringify(query)).toString();\n\n      // Check cache for hits.\n      var hits = searchCache.get(cid);\n      if (hits !== undefined) {\n        // Update filters cache.\n        if (hits.hasOwnProperty('aggs')) {\n          currentFilters = parseFilters(angular.copy(hits.aggs));\n        }\n\n        deferred.resolve(hits);\n      }\n      else {\n        connect().then(function () {\n          socket.emit('search', query);\n          socket.once('result', function (hits) {\n\n            // Update cache filters cache.\n            if (hits.hasOwnProperty('aggs')) {\n              // Store current filters.\n              currentFilters = parseFilters(angular.copy(hits.aggs));\n            }\n\n            // Save hits in cache.\n            searchCache.put(cid, hits);\n\n            deferred.resolve(hits);\n          });\n\n          // Catch search errors.\n          socket.once('searchError', function (error) {\n            console.error('Search error', error.message);\n            deferred.reject(error.message);\n          });\n        });\n      }\n\n      return deferred.promise;\n    };\n  }\n]);\n","/**\n * @file\n * Service to communication between search box and search result applications.\n */\n\nangular.module('communicationService', [])\n  .service('communicatorService', function($rootScope, $window){\n    'use strict';\n\n    // Store rootScopes for each service user.\n    $window.rootScopes = $window.rootScopes || [];\n    $window.rootScopes.push($rootScope);\n\n    /**\n     * Wrapper for emitting events to all root scopes.\n     *\n     * @param name\n     *   Event name\n     * @param args\n     *   Event arguments.\n     */\n    this.$emit = function emit(name, args) {\n      angular.forEach($window.rootScopes, function(scope) {\n        scope.$emit(name, args);\n      });\n    };\n\n    /**\n     * Wrapper to attach event listeners to the current root scope.\n     *\n     * @param name\n     *   Event name.\n     * @param listener\n     *   The listener to call on event.\n     */\n    this.$on = function on(name, listener) {\n      $rootScope.$on(name, function (event, message) {\n        listener.apply($rootScope, [event, message]);\n      });\n    };\n  });","/**\n * @file\n * Search proxy.\n *\n * Allows the framework to use different search back-ends based on\n * configuration settings.\n */\n\n/**\n * Search proxy is used to send search requests to the configured provide.\n */\nangular.module('searchBoxApp').service('searchProxy', ['CONFIG', 'communicatorService', '$injector',\n  function (CONFIG, communicatorService, $injector) {\n    'use strict';\n\n    // Load provider based on configuration.\n    var provider = $injector.get(CONFIG.provider.service);\n\n    /**\n     * Search the provider loaded.\n     *\n     * This simply forwards the search request to the provider loaded.\n     *\n     * @param query\n     *   The search query.\n     *\n     * @returns {Number|*|Object}\n     *   The search result.\n     */\n    this.search = function search(query) {\n      return provider.search(query);\n    };\n\n    /**\n     * Get filters provided by search engine used.\n     *\n     * @returns json\n     */\n    this.getFilters = function getFilters() {\n      return provider.getFilters();\n    };\n  }\n]);\n"],"sourceRoot":"/source/"}