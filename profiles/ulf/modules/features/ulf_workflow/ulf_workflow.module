<?php
/**
 * @file
 * Code for the Ulf workflow feature.
 */

include_once 'ulf_workflow.features.inc';
include_once 'includes/ulf_workflow_submit_handlers.inc';
include_once 'includes/ulf_workflow_form_validation.inc';
include_once 'includes/ulf_workflow_form_moderations.inc';
include_once 'includes/ulf_workflow_cron.inc';
include_once 'includes/ulf_workflow_mail.inc';

/**
 * Implements hook_preprocess_hook().
 *
 * Hide stuff for version comparison on diff pages.
 *
 * @param $variables
 */
function ulf_workflow_preprocess_page(&$variables) {
  // Quick check to ensure we don't search array on all page calls.
  if ($GLOBALS['theme'] == 'seven') {
    if (in_array('page__node__revisions__view', $variables['theme_hook_suggestions'])) {
      if (isset($variables['page']['content']['system_main']['diff_preview'])) {
        unset($variables['page']['content']['system_main']['diff_preview']);
      }
      if (isset($variables['page']['content']['system_main']['diff_table'])) {
        unset($variables['page']['content']['system_main']['diff_table']['#rows']['logs']);
        unset($variables['page']['content']['system_main']['diff_table']['#rows']['navigation']);
        unset($variables['page']['content']['system_main']['diff_table']['#rows']['states']);
      }
    }
  }
}

/**
 * Implements hook_menu_link_alter().
 *
 * Change the title of my content workbench tab (Hardcoded from workbench module.)
 */
function ulf_workflow_menu_alter(&$items) {
  if (array_key_exists('admin/workbench/content', $items)) {
    $items['admin/workbench/content']['access callback'] = 'ulf_workflow_workbench_access';
  }
}

/**
 * Deny access to workbench.
 *
 * @return bool
 */
function ulf_workflow_workbench_access() {
  return FALSE;
}

/**
 * Implements hook_menu_local_tasks_alter.
 *
 * Change revision view access.
 */
function ulf_workflow_menu_local_tasks_alter(&$data) {
  global $user;
  if (in_array('course provider', $user->roles)) {
    if ($data['tabs']) {
      $tabs = $data['tabs']['0']['output'];
      foreach ($tabs as $key => $tab) {
        if ($tab['#link']['path'] == 'node/%/moderation') {
          unset($data['tabs']['0']['output'][$key]);
        }
      }
    }
  }

  // Default workbench tab not used by editors.
  if (in_array('editor', $user->roles)) {
    if ($data['tabs']) {
      $tabs = $data['tabs']['0']['output'];
      foreach ($tabs as $key => $tab) {
        if ($tab['#link']['path'] == 'admin/workbench/content') {
          unset($data['tabs']['0']['output'][$key]);
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add workflow actions to node course type.
 *
 * @param $form
 * @param $form_state
 * @param $form_id
 */
function ulf_workflow_form_node_form_alter(&$form, &$form_state, $form_id) {
  $content_type = $form['#node']->type;
  
  // Content types that have workflow enabled.
  $workflow_enabled_types = array(
    'course',
    'course_educators',
    'news_course_provider'
  );

  // Check for workflow enabled.
  if (in_array($content_type, $workflow_enabled_types)) {
    // Inform of current workflow state
    $trashed = isset($form['#node']->field_trashed['und'][0]['value']) ? $form['#node']->field_trashed['und'][0]['value'] : FALSE;
    if($trashed) {
      drupal_set_message(t('The current workflow state for this content is: Trash'), 'warning');
    }
    elseif(isset($form['clone_from_original_nid']['#value'])){
      global $user;
      $node = node_load($form['clone_from_original_nid']['#value']);
      drupal_set_message(t('This is a clone of "@title."', array('@title' => $node->title)), 'warning');
      if ($form['uid']['#value'] != $user->uid) {
        drupal_set_message(t('Remember to change the author of this content to assign it to the right course provider.') ,'warning');
      }
    }
    elseif(isset($form['workbench_moderation_state_current']['#value'])) {
      $readable_state = workbench_moderation_state_load($form['workbench_moderation_state_current']['#value']);
      drupal_set_message(t('The current workflow state for this content is: @state.', array('@state' => $readable_state->label)), 'warning');
    }
    
    $node_action = isset($form['#node']->nid) ? 'edit' : 'add';
    // Remove unused fields and actions.
    _ulf_workflow_cleanup_form($form);
    if ($node_action == 'add'){
      _ulf_workflow_provide_add_actions($form);
    }
    else {
      _ulf_workflow_provide_edit_actions($form);
    }

    // Add image form validation.
    $form['#validate'][] = '_ulf_workflow_form_validate_image';
  }
}

/**
 * Implements hook_user_update().
 *
 * @param $edit
 * @param $account
 * @param $category
 */
function ulf_workflow_user_update(&$edit, $account, $category) {
  _send_user_edited_mail($account);
}


/**
 * Implements hook_scheduler_api().
 *
 * Send mails when publishing and unpublishing content through scheduler.
 */
function ulf_workflow_scheduler_api($node, $action) {
  switch ($action) {
    case 'publish' :
      _send_published_mail($node);
      break;
    case 'unpublish' :
      _send_unpublished_mail($node);
      break;
    default:
  }
}

/**
 * Implements hook_node_insert().
 *
 * Set a destination parameter when the node is first saved.
 * Send mail on node creation.
 *
 * @param $node
 */
function ulf_workflow_node_insert($node) {
  // Content types that have workflow enabled.
  $workflow_enabled_types = array(
    'course',
    'course_educators',
    'news_course_provider'
  );

  if (in_array($node->type, $workflow_enabled_types)) {
    // Send mail on creation.
    // We can't use form submit on node add to send mail, since we need a full
    // node entity for displaying the mail and it is not created before now.
    if ($node->workbench_moderation_state_new == 'published' && user_access('moderate content from needs_review to published')) {
      _send_published_mail($node);
    }

    if ($node->workbench_moderation_state_new == 'needs_review') {
      _send_revision_ready_mail($node);
    }
    
    $_GET['destination'] = 'node/' . $node->nid . '/edit';
  }
}

/**
 * Implements hook_node_update().
 *
 * Set a destination parameter when the node is updated.
 */
function ulf_workflow_node_update($node) {
  global $user;

  if ($user->uid > 0) {
    $_GET['destination'] = 'node/' . $node->nid . '/edit';
  }
}

/**
 * Check if user can publish their own content.
 *
 * @return bool
 *   Whether the user can publish own content.
 */
function _ulf_workflow_check_publish_permission() {
  global $user;
  $full_user = user_load($user->uid);
  $user_wrapper = entity_metadata_wrapper('user', $full_user);

  // Check if user can bypass workflow.
  // Done this way since we need clean true or false (We don't want empty when field is not filled).
  $user_bypass = $user_wrapper->field_bypass_workflow->value() == TRUE ? TRUE : FALSE;

  if (user_access('moderate content from needs_review to published') || $user_bypass) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_cron().
 */
function ulf_workflow_cron() {
  _ulf_workflow_cron_empty_trash();
}
