/**
 * @name Search node Angular library
 * @version v1.0.11
 * @link https://github.com/search-node/searchpt
 */
{"version":3,"sources":["search.js","providers/jsonProvider.js","providers/searchNodeProvider.js","directive/keyCodeDirective.js","directive/pagerDirective.js","services/communicationService.js","services/searchProxyService.js","controllers/boxController.js","controllers/resultController.js"],"names":["angular","module","element","document","ready","result","getElementById","bootstrap","console","error","box","service","CONFIG","$q","$http","data","get","provider","then","res","this","getFilters","tags","name","type","items","value","levels","search","query","self","hits","copy","deferred","defer","text","JSON","forEach","filters","filter","xp","enabled","resolve","length","results","promise","CacheFactory","objectSize","obj","size","key","hasOwnProperty","loadSocketIoScript","loadedSocketIo","script","createElement","readyState","onreadystatechange","onload","src","configuration","host","getElementsByTagName","appendChild","getSocket","socket","io","connect","token","force new connection","max reconnection attempts","Infinity","on","reason","reject","undefined","auth","success","status","buildAggregationQuery","aggs","i","terms","field","parseFilters","j","buckets","bucket","count","Number","doc_count","currentFilters","searchCache","id","maxAge","cacheExpire","deleteOnExpire","storageMode","getRawFilters","cachedFilters","emit","once","counts","put","message","searchQuery","index","filtered","match_all","fields","boost","multi_match","analyzer","queryFilter","bool","must","execution","term","push","pager","from","page","extend","intervals","interval","range","gte","lte","to","should","dates","config","template","gt","lt","cid","CryptoJS","MD5","stringify","toString","directive","restrict","link","$scope","$element","$attrs","bind","event","keyCode","which","code","$apply","$eval","$event","replace","scope","controller","changePage","prevPage","nextPage","max","$watch","pages","Math","ceil","templateUrl","templates","$rootScope","$window","rootScopes","$emit","args","$on","listener","apply","communicatorService","$injector","encodeSearchQuery","parts","encodeURIComponent","filterParts","selected","join","intervalParts","dateParts","date","decodeSearhQuery","string","substr","split","part","subparts","decodeURIComponent","reduce","val","init","state","hash","window","location","force","forces","values","searchProxyService","initialQueryText","searchProxyServiceService","pagerUpdated","phase","$root","$$phase","searchClicked","searching"],"mappings":"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","file":"search.js","sourcesContent":["\n/**\n * @file\n * Defines the Angular JS application.\n */\n\n// Define the angular applications.\nangular.module('searchBoxApp', ['communicationService', 'searchAppConfig', 'angular-cache']);\nangular.module('searchResultApp', ['communicationService', 'searchAppConfig', 'ngSanitize']);\n\n/**\n * When the document is ready bootstrap the two applications.\n */\nangular.element(document).ready(function ready() {\n  \"use strict\";\n\n  // Bootstrap the search result area. This has to be booted first to ensure\n  // that it's ready for events from the search box bootstrap process.\n  var result = document.getElementById(\"searchResultApp\");\n  if (result) {\n    angular.bootstrap(result, ['searchResultApp']);\n  }\n  else {\n    console.error('Unable to bootstrap searchResultApp. Missing HTML tag with id \"searchResultApp\"');\n  }\n\n  // Bootstrap search box.\n  var box = document.getElementById(\"searchBoxApp\");\n  if (box) {\n    angular.bootstrap(box, ['searchBoxApp']);\n  }\n  else {\n    console.error('Unable to bootstrap searchBoxApp. Missing HTML tag with id \"searchBoxApp\"');\n  }\n});\n","/**\n * @file\n * Dummy search provider that reads the search results from a JSON file.\n */\n\n/**\n * Search provider for JSON files.\n */\nangular.module('searchBoxApp').service('jsonProvider', ['CONFIG', '$q', '$http',\n  function (CONFIG, $q, $http) {\n    'use strict';\n\n    // Load JSON file based on configuration.\n    var data = [];\n    $http.get(CONFIG.provider.data)\n      .then(function(res){\n        data = res.data;\n      });\n\n    /**\n     * The filters available.\n     *\n     * @returns json array.\n     */\n    this.getFilters = function getFilters() {\n      return {\n        'tags': {\n          'name': 'Tags',\n          'type': 'and',\n          'items': [\n            {\n              'name': 'Angular',\n              'value': 'angular'\n            },\n            {\n              'name': 'Developer',\n              'value': 'developer'\n            },\n            {\n              'name': 'Javascript',\n              'value': 'javascript'\n            },\n            {\n              'name': 'Chrome',\n              'value': 'chrome'\n            }\n          ]\n        },\n        'levels':{\n          'name': 'Levels (or)',\n          'type': 'or',\n          'items': [\n            {\n              'name': 'First',\n              'value': 1\n            },\n            {\n              'name': 'Second',\n              'value': 2\n            },\n            {\n              'name': 'Third',\n              'value': 3\n            },\n            {\n              'name': 'Fourth',\n              'value': 4\n            }\n          ]\n        }\n      };\n    };\n\n    /**\n     * Search function to query the json data.\n     *\n     * @param query\n     *   The query parameters to search\n     *\n     * @returns {Array}\n     *   The hits found.\n     */\n    this.search = function search(query) {\n      var self = this;\n      var hits = angular.copy(data);\n\n      var deferred = $q.defer();\n\n      // Search title.\n      if (query.text !== '') {\n        hits = JSON.search(data, '//*[contains(title, \"' + query.text + '\")]');\n      }\n\n      // Search filters.\n      angular.forEach(query.filters, function (filter, name) {\n        // Get search type 'or' or 'and'.\n        var type = self.getFilters();\n        var xp = false;\n\n        angular.forEach(filter, function (enabled, value) {\n          if (enabled) {\n            if (type === 'or') {\n              // Or type search needs to build and xpath expression for all items\n              // in the filter.\n              if (xp === false) {\n                xp = '//*[' + name + '=\"' + value + '\"]';\n              }\n              else {\n                xp += '|//*[' + name + '=\"' + value + '\"]';\n              }\n            }\n            else {\n              // \"And\" type search simply limites the results.\n              hits = JSON.search(hits, '//*[' + name + '=\"' + value + '\"]');\n            }\n          }\n        });\n\n        // After all other search apply the \"or\" search expression.\n        if (type === 'or' && xp) {\n          hits = JSON.search(hits, xp);\n        }\n      });\n\n      // This may seem strange, but it's to keep up with the way search node\n      // works. So it makes sense to return and resolve the promise just after\n      // each other.\n      deferred.resolve({\n        'hits': hits.length,\n        'results': hits\n      });\n\n      return deferred.promise;\n    };\n  }\n]);\n","/**\n * @file\n * Search provider for the search node framework.\n */\n\nangular.module('searchBoxApp').service('searchNodeProvider', ['CONFIG', '$q', '$http', 'CacheFactory',\n  function (CONFIG, $q, $http, CacheFactory) {\n    'use strict';\n\n    // Configuration options.\n    var configuration = CONFIG.provider;\n\n    // Search node connection handling.\n    var socket;\n    var loadedSocketIo = false;\n    var token = null;\n\n    // Create cache object.\n    var searchCache = new CacheFactory('searchCache' + CONFIG.id, {\n      maxAge: configuration.cacheExpire * 1000,\n      deleteOnExpire: 'aggressive',\n      storageMode: 'localStorage'\n    });\n\n    // Holder for the latest search query filters.\n    var currentFilters;\n\n    /**\n     * Find the size of given object.\n     *\n     * @TODO: Review - Size: as in number of properties? Maybe change naming?\n     *\n     * @return int\n     *   The size of the object or 0 if empty.\n     */\n    function objectSize(obj) {\n      var size = 0;\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          size++;\n        }\n      }\n\n      return size;\n    }\n\n    /**\n     * Load the socket.io library provided by the search node.\n     *\n     * @return {promise}\n     *   An promise is return that will be resolved on library loaded.\n     */\n    function loadSocketIoScript() {\n      var deferred = $q.defer();\n\n      // Check if it have been loaded.\n      if (!loadedSocketIo) {\n        // Create script element.\n        var script = document.createElement(\"script\");\n        script.type = \"text/javascript\";\n\n        // Add event handlers for the library loaded.\n        if (script.readyState) {\n          // Handle Internet Explore.\n          script.onreadystatechange = function () {\n            if (script.readyState === \"loaded\" || script.readyState === \"complete\") {\n              script.onreadystatechange = null;\n              loadedSocketIo = true;\n              deferred.resolve();\n            }\n          };\n        } else {\n          // All other browsers.\n          script.onload = function () {\n            loadedSocketIo = true;\n            deferred.resolve();\n          };\n        }\n\n        // Add the script and add it to the dom to load it.\n        script.src = configuration.host + \"/socket.io/socket.io.js\";\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n      }\n      else {\n        deferred.resolve();\n      }\n\n      return deferred.promise;\n    }\n\n    /**\n     * Connect to the web-socket.\n     *\n     * @param deferred\n     *   The deferred object that should be resolved on connection.\n     */\n    function getSocket(deferred) {\n      // Load the socket library.\n      loadSocketIoScript().then(function () {\n        // Get connected to the server.\n        socket = io.connect(configuration.host, {\n          'query': 'token=' + token,\n          'force new connection': true,\n          'max reconnection attempts': Infinity\n        });\n\n        // Handle error events.\n        socket.on('error', function (reason) {\n          console.error(reason, 'Search socket error.');\n          deferred.reject(reason);\n        });\n\n        socket.on('connect', function () {\n          deferred.resolve('Connected to the server.');\n        });\n\n        // Handle disconnect event (fires when disconnected or connection fails).\n        socket.on('disconnect', function (reason) {\n          // @todo: re-connection is automatically handled by socket.io library,\n          // but we might need to stop sending request until reconnection or the\n          // request will be queued and sent all at once... which could give\n          // some strange side effects in the application if not handled.\n        });\n      });\n    }\n\n    /**\n     * Create the connection to the server.\n     *\n     * @return {promise}\n     *   A promise is return that will be resolved on connection.\n     */\n    function connect() {\n      // Try to connect to the server if not already connected.\n      var deferred = $q.defer();\n\n      if (socket === undefined) {\n        if (token !== null) {\n          getSocket(deferred);\n        }\n        else {\n          $http.get(configuration.auth)\n            .success(function (data) {\n              token = data.token;\n              getSocket(deferred);\n            })\n            .error(function (data, status) {\n              console.error(data, 'Authentication (search) to search node failed (' + status + ')');\n              deferred.reject(status);\n            });\n        }\n      }\n      else {\n        deferred.resolve('Connected to the server.');\n      }\n\n      return deferred.promise;\n    }\n\n    /**\n     * Builds aggregation query based on filters.\n     *\n     * @param filters\n     */\n    function buildAggregationQuery(filters) {\n      // Basic aggregation query.\n      var query = {\n        \"aggs\": {}\n      };\n\n      // Extend query with filter fields.\n      for (var i = 0; i < filters.length; i++) {\n        var filter = filters[i];\n        query.aggs[filter.name] = {\n          \"terms\": {\n            \"field\": filter.field,\n            \"size\": 0\n          }\n        };\n      }\n\n      return query;\n    }\n\n    /**\n     * Parse filter configuration and search aggregations.\n     *\n     * Merge result with filters configuration as not all terms may have\n     * been used in the content and then not in found in the search\n     * node.\n     *\n     * @param aggs\n     *\n     * @returns {{}}\n     */\n    function parseFilters(aggs) {\n      var results = {};\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        var filters = CONFIG.provider.filters;\n\n        for (var i = 0; i < filters.length; i++) {\n          var filter = angular.copy(filters[i]);\n\n          // Set basic filter with counts.\n          results[filter.field] = {\n            'name': filter.name,\n            'items': filter.terms\n          };\n\n          // Run through counts and update the filter.\n          if (objectSize(aggs) !== 0) {\n            for (var j = 0; j < aggs[filter.name].buckets.length; j++) {\n              var bucket = aggs[filter.name].buckets[j];\n              if (results[filter.field].items.hasOwnProperty(bucket.key)) {\n                results[filter.field].items[bucket.key].count = Number(bucket.doc_count);\n              }\n              else {\n                console.error('Filter value don\\'t match configuration: ' + filter.field + ' -> ' + bucket.key);\n              }\n            }\n          }\n        }\n      }\n\n      return results;\n    }\n    /**\n     * Get the list of available filters not parsed with search results.\n     *\n     * @return object\n     *  The filters from the configuration.\n     */\n    this.getRawFilters = function getRawFilters() {\n      var result = {};\n\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        var filters = CONFIG.provider.filters;\n        for (var i = 0; i < filters.length; i++) {\n\n          // Set basic filter with counts.\n          result[filters[i].field] = {\n            'name': filters[i].name,\n            'items': filters[i].terms\n          };\n        }\n      }\n\n      return result;\n    };\n\n    /**\n     * Get the list of available filters.\n     *\n     * @PLAN:\n     *   Check if latest search returned aggregations, if not use the\n     *   configuration to search the get all available aggregations.\n     *\n     *   Merge it with configuration to ensure that all possible filters are\n     *   displayed with count.\n     */\n    this.getFilters = function getFilters() {\n      var deferred = $q.defer();\n\n      // Get filters from configuration.\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        var filters = CONFIG.provider.filters;\n\n        // If no search has been executed yet, load the default filters across\n        // all indexed data.\n        if (currentFilters === undefined) {\n          // Check if filters are cached.\n          var cachedFilters = searchCache.get('filters');\n\n          if (cachedFilters !== undefined) {\n            // Store current filters.\n            currentFilters = cachedFilters;\n\n            // Return the result.\n            deferred.resolve(angular.copy(currentFilters));\n          }\n          else {\n            // Get the query.\n            var query = buildAggregationQuery(filters);\n\n            /**\n             * @TODO: Added forced fields and other search options.\n             */\n\n            // Send the request to search node.\n            connect().then(function () {\n              socket.emit('count', query);\n              socket.once('counts', function (counts) {\n                var results = parseFilters(counts);\n\n                // Store initial filters in cache.\n                searchCache.put('filters', results);\n\n                // Store current filters.\n                currentFilters = results;\n\n                // Return the result.\n                deferred.resolve(results);\n              });\n\n              // Catch search errors.\n              socket.once('searchError', function (error) {\n                console.error('Search error', error.message);\n                deferred.reject(error.message);\n              });\n            });\n          }\n        }\n        else {\n          // Return the result.\n          deferred.resolve(angular.copy(currentFilters));\n        }\n      }\n      else {\n        deferred.resolve({});\n      }\n\n      return deferred.promise;\n    };\n\n    /**\n     * Execute search query.\n     *\n     * @param searchQuery\n     * @returns {*}\n     */\n    this.search = function search(searchQuery) {\n      var deferred = $q.defer();\n\n      // Build default \"match all\" search query.\n      var query = {\n        \"index\": configuration.index,\n        \"query\": {\n          \"filtered\": {\n            \"query\": {\n              \"match_all\": {}\n            }\n          }\n        }\n      };\n\n      // Text given build field search query.\n      // The analyser ensures that we match the who text string sent not part\n      // of.\n      if (searchQuery.text !== undefined && searchQuery.text !== '') {\n        var fields = configuration.fields;\n        // Check if boost exist for the fields.\n        if (configuration.hasOwnProperty('boost') && objectSize(configuration.boost)) {\n          // Add boost to fields.\n          for (var i in fields) {\n            if (configuration.boost.hasOwnProperty(fields[i])) {\n              fields[i] = fields[i] + '^' + configuration.boost[fields[i]];\n            }\n          }\n        }\n\n        query.query.filtered.query = {\n          \"multi_match\": {\n            \"query\": searchQuery.text,\n            \"fields\": fields,\n            \"analyzer\": 'string_search'\n          }\n        };\n      }\n\n      // Add filter.\n      if (searchQuery.hasOwnProperty('filters')) {\n        var filters = angular.copy(searchQuery.filters);\n\n        // Build query filter.\n        var queryFilter = {\n          \"bool\": {\n            \"must\": []\n          }\n        };\n\n        // Load over all filters.\n        for (var field in filters) {\n          /**\n           * @TODO: Needs to get information from configuration about execution\n           *        type?\n           */\n          var terms = {\n            \"execution\": \"and\"\n          };\n\n          terms[field] = [];\n          for (var term in filters[field]) {\n            // Check the the term is \"true\", hence is selected.\n            if (filters[field][term]) {\n              terms[field].push(term);\n            }\n          }\n\n          if (terms[field].length) {\n            queryFilter.bool.must.push({ \"terms\": terms });\n          }\n        }\n\n        // Add the query filter if filled out.\n        if (queryFilter.bool.must.length) {\n          query.query.filtered.filter = queryFilter;\n        }\n      }\n\n      // Add pager to the query.\n      if (searchQuery.hasOwnProperty('pager')) {\n        query.size = searchQuery.pager.size;\n        query.from = searchQuery.pager.page * searchQuery.pager.size;\n      }\n\n      // Check if aggregations/filters counts should be used.\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        // Get the query.\n        var aggs = buildAggregationQuery(CONFIG.provider.filters);\n        angular.extend(query, aggs);\n      }\n\n      // Add range/interval search to the query.\n      if (searchQuery.hasOwnProperty('intervals')) {\n        // Check if any filters have been defined.\n        if (!query.query.filtered.hasOwnProperty('filter')) {\n          query.query.filtered.filter = {\n            \"bool\": {\n              \"must\": []\n            }\n          };\n        }\n\n        // Loop over the intervals and build range terms.\n        for (var field in searchQuery.intervals) {\n          var interval = {\n            \"range\": {}\n          };\n          interval.range[field] = {\n            \"gte\": searchQuery.intervals[field].from,\n            \"lte\": searchQuery.intervals[field].to\n          };\n          query.query.filtered.filter.bool.must.push(interval);\n        }\n      }\n\n      // Add date interval search.\n      if (searchQuery.hasOwnProperty('dates')) {\n        // Check if any filters have been defined.\n        if (!query.query.filtered.hasOwnProperty('filter')) {\n          query.query.filtered.filter = {\n            \"bool\": {\n              \"should\": [ ]\n            }\n          };\n        }\n        else {\n          query.query.filtered.filter.bool.should = [];\n        }\n\n        // Loop over the intervals and build range terms.\n        for (var field in searchQuery.dates) {\n          var config = configuration.dates[field];\n          var template = {\n            \"bool\": {\n              \"must\": [\n                {\n                  \"range\": {}\n                },\n                {\n                  \"range\": {}\n                }\n              ]\n            }\n          };\n\n          // Overlap start of the interval.\n          template.bool.must[0].range[config.from] = {\n            \"lte\": searchQuery.dates[field].from\n          };\n          template.bool.must[1].range[config.to] = {\n            \"gt\": searchQuery.dates[field].from\n          };\n          query.query.filtered.filter.bool.should.push(angular.copy(template));\n\n          // Overlap end of the interval.\n          template.bool.must[0].range[config.from] = {\n            \"lt\": searchQuery.dates[field].to\n          };\n          template.bool.must[1].range[config.to] = {\n            \"gte\": searchQuery.dates[field].to\n          };\n          query.query.filtered.filter.bool.should.push(angular.copy(template));\n\n          // Overlap both endes of the interval.\n          template.bool.must[0].range[config.from] = {\n            \"gte\": searchQuery.dates[field].from\n          };\n          template.bool.must[1].range[config.to] = {\n            \"lte\": searchQuery.dates[field].to\n          };\n          query.query.filtered.filter.bool.should.push(angular.copy(template));\n        }\n      }\n\n      // Create cache key based on the finale search query.\n      var cid = CryptoJS.MD5(JSON.stringify(query)).toString();\n\n      // Check cache for hits.\n      var hits = searchCache.get(cid);\n      if (hits !== undefined) {\n        // Update filters cache.\n        if (hits.hasOwnProperty('aggs')) {\n          currentFilters = parseFilters(angular.copy(hits.aggs));\n        }\n\n        deferred.resolve(hits);\n      }\n      else {\n        connect().then(function () {\n          socket.emit('search', query);\n          socket.once('result', function (hits) {\n            // Update cache filters cache, based on the current search result.\n            if (hits.hasOwnProperty('aggs')) {\n              // Store current filters.\n              currentFilters = parseFilters(angular.copy(hits.aggs));\n            }\n\n            // Save hits in cache.\n            searchCache.put(cid, hits);\n\n            deferred.resolve(hits);\n          });\n\n          // Catch search errors.\n          socket.once('searchError', function (error) {\n            console.error('Search error', error.message);\n            deferred.reject(error.message);\n          });\n        });\n      }\n\n      return deferred.promise;\n    };\n  }\n]);\n","/**\n * @file\n * Directive to capture key codes.\n *\n * @see http://codepen.io/TheLarkInn/blog/angularjs-directive-labs-ngenterkey.\n *\n * Use by adding html attributes:\n *   data-code=\"key_code_to_capture\"\n *   data-key-code=\"function_to_call()\"\n */\nangular.module('searchBoxApp').directive('keyCode', function keyCode() {\n  'use strict';\n\n  return {\n    restrict: 'A',\n    link: function($scope, $element, $attrs) {\n      $element.bind(\"keypress\", function(event) {\n        var keyCode = event.which || event.keyCode;\n        if (keyCode === Number($attrs.code)) {\n          $scope.$apply(function() {\n            $scope.$eval($attrs.keyCode, { $event: event });\n          });\n        }\n      });\n    }\n  };\n});\n","/**\n * @file\n * Paging directive.\n */\n\n/**\n * Paging directive.\n *\n * @TODO: Review - maybe use the newer version from https://github.com/aroskanalen/admin/tree/development/web/app/shared/elements/pager\n */\nangular.module('searchResultApp').directive('searchPager', ['CONFIG',\n  function (CONFIG) {\n    'use strict';\n\n    return {\n      restrict: 'E',\n      replace: true,\n      scope: true,\n      controller: function ($scope) {\n\n        /**\n         * Click handler to change page.\n         *\n         * @param page\n         */\n        $scope.changePage = function changePage(page) {\n          $scope.pager.page = page;\n          $scope.search();\n        };\n\n        $scope.prevPage = function prevPage() {\n          if ($scope.pager.page > 0) {\n            $scope.pager.page--;\n            $scope.search();\n          }\n        };\n\n        $scope.nextPage = function nextPage() {\n          if ($scope.pager.page < $scope.pager.max - 1) {\n            $scope.pager.page++;\n            $scope.search();\n          }\n        };\n\n        // Keep a watch on changes in number of hits.\n        $scope.$watch('hits', function (hits) {\n          var pages = [];\n          $scope.pager.max = 0;\n          if (hits.hits > $scope.pager.size) {\n            $scope.pager.max = Math.ceil(hits.hits / $scope.pager.size);\n            for (var i = 0; i < $scope.pager.max; i++) {\n              pages.push(i);\n            }\n          }\n          $scope.pager.pages = pages;\n        });\n      },\n      templateUrl: CONFIG.templates.pager\n    };\n  }\n]);\n","/**\n * @file\n * Service to communication between search box and search result applications.\n */\n\nangular.module('communicationService', [])\n  .service('communicatorService', function($rootScope, $window){\n    'use strict';\n\n    // Store rootScopes for each service user.\n    $window.rootScopes = $window.rootScopes || [];\n    $window.rootScopes.push($rootScope);\n\n    /**\n     * Wrapper for emitting events to all root scopes.\n     *\n     * @param name\n     *   Event name\n     * @param args\n     *   Event arguments.\n     */\n    this.$emit = function emit(name, args) {\n      angular.forEach($window.rootScopes, function(scope) {\n        scope.$emit(name, args);\n      });\n    };\n\n    /**\n     * Wrapper to attach event listeners to the current root scope.\n     *\n     * @param name\n     *   Event name.\n     * @param listener\n     *   The listener to call on event.\n     */\n    this.$on = function on(name, listener) {\n      $rootScope.$on(name, function (event, message) {\n        listener.apply($rootScope, [event, message]);\n      });\n    };\n  });","/**\n * @file\n * Search proxy.\n *\n * Allows the framework to use different search back-ends based on\n * configuration settings.\n */\n\n/**\n * Search proxy is used to send search requests to the configured provider.\n */\nangular.module('searchBoxApp').service('searchProxyService', ['CONFIG', 'communicatorService', '$injector',\n  function (CONFIG, communicatorService, $injector) {\n    'use strict';\n\n    // Load provider based on configuration.\n    var provider = $injector.get(CONFIG.provider.service);\n\n    /**\n     * Find the size of given object.\n     *\n     * @TODO: Review - Size: as in number of properties? Maybe change naming?\n     *\n     * @return int\n     *   The size of the object or 0 if empty.\n     */\n    function objectSize(obj) {\n      var size = 0;\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          size++;\n        }\n      }\n\n      return size;\n    }\n\n    /**\n     * Encode the query object into a string.\n     *\n     * @param query\n     *   The query object.\n     *\n     * @return string\n     *   The encoded string that can been used as hash tag in url.\n     */\n    function encodeSearchQuery(query) {\n      var parts = [];\n\n      // Search text.\n      if (query.hasOwnProperty('text') && query.text.length !== 0) {\n        parts.push('text=' + encodeURIComponent(query.text));\n      }\n\n      // Filters.\n      if (query.hasOwnProperty('filters') && objectSize(query.filters) !== 0) {\n        var filterParts = [];\n        for (var field in query.filters) {\n          var selected = [];\n          for (var filter in query.filters[field]) {\n            if (query.filters[field][filter] === true) {\n              selected.push(filter);\n            }\n          }\n\n          // Only add the filter if filter have selections.\n          if (selected.length) {\n            filterParts.push(field + ':' + selected.join(';'));\n          }\n        }\n\n        // Only encode filters if any have be selected.\n        if (filterParts.length) {\n          parts.push('filters=' + encodeURIComponent(filterParts.join('?')));\n        }\n      }\n\n      // Interval search.\n      if (query.hasOwnProperty('intervals') && objectSize(query.intervals) !== 0) {\n        var intervalParts = [];\n        for (var field in query.intervals) {\n          var interval = query.intervals[field];\n          intervalParts.push(field + ';' + interval.from + ';' + interval.to);\n        }\n        parts.push('intervals=' + encodeURIComponent(intervalParts.join('?')));\n      }\n\n      // Date search.\n      if (query.hasOwnProperty('dates') && objectSize(query.dates) !== 0) {\n        // @TODO: This is the same as for intervals. Refactor into function or\n        // loop over type.\n        var dateParts = [];\n        for (var field in query.dates) {\n            var date = query.dates[field];\n          dateParts.push(field + ';' + date.from + ';' + date.to);\n        }\n        parts.push('dates=' + encodeURIComponent(dateParts.join('?')));\n      }\n\n      // Pager page.\n      if (query.hasOwnProperty('pager')) {\n        parts.push('pager=' + query.pager.page + ':' + query.pager.size);\n      }\n\n      return parts.join('&');\n    }\n\n    /**\n     * Decode the hash tag string into search query object.\n     *\n     * @param string\n     *   The encode string that can be used as hash tag in url.\n     *\n     * @return object\n     *   Search query object.\n     */\n    function decodeSearhQuery(string) {\n      var query = {};\n\n      // Get parts.\n      var parts = string.substr(2).split('&');\n      for (var part in parts) {\n        var subparts = parts[part].split('=');\n        switch (subparts[0]) {\n          case 'text':\n            query.text = decodeURIComponent(subparts[1]);\n            break;\n\n          case 'filters':\n            var filters = decodeURIComponent(subparts[1]).split('?');\n            if (filters.length) {\n              query.filters = {};\n              for (var i in filters) {\n                var filter = filters[i].split(':');\n                // Reduce the array values into an object.\n                query.filters[filter[0]] = filter[1].split(';').reduce(function (obj, val, index) {\n                  obj[val] = true;\n                  return obj;\n                }, {});\n              }\n            }\n            break;\n\n          case 'intervals':\n            var intervals = decodeURIComponent(subparts[1]).split('?');\n            if (intervals.length) {\n              query.intervals = {};\n              for (var i in intervals) {\n                var interval = intervals[i].split(';');\n                query.intervals[interval[0]] = {\n                  'from': interval[1],\n                  'to': interval[2]\n                };\n              }\n            }\n            break;\n\n          // @TODO: This is the same as for intervals. Refactor into function.\n          case 'dates':\n            var dates = decodeURIComponent(subparts[1]).split('?');\n            if (dates.length) {\n              query.dates = {};\n              for (var i in dates) {\n                var date = dates[i].split(';');\n                query.dates[date[0]] = {\n                  'from': date[1],\n                  'to': date[2]\n                };\n              }\n            }\n            break;\n\n          case 'pager':\n            var pager = subparts[1].split(':');\n            query.pager = {\n              'page': Number(pager[0]),\n              'size': Number(pager[1])\n            };\n            break;\n\n          default:\n            console.error('Decoding of search hash has unknown parts - ' + subparts[0]);\n        }\n      }\n\n      return query;\n    }\n\n    /**\n     * Get basic information about the search state.\n     *\n     * @return object\n     *  The last query form hash tag and default filters.\n     */\n    this.init = function init() {\n      var state = {\n        'filters': this.getRawFilters()\n      };\n\n      var hash = window.location.hash;\n      if (hash.length > 2) {\n         state.query = decodeSearhQuery(hash);\n      }\n\n      return state;\n    };\n\n    /**\n     * Search the provider loaded.\n     *\n     * This simply forwards the search request to the provider loaded.\n     *\n     * @param searchQuery\n     *   The search query.\n     *\n     * @returns {Number|*|Object}\n     *   The search result.\n     */\n    this.search = function search(searchQuery) {\n      // Ensure that forced fields and other changes are not reflected in the\n      // UI.\n      var query = angular.copy(searchQuery);\n\n      // Ensure that intervals are set in the configuration and have both from\n      // and to values.\n      if (CONFIG.provider.hasOwnProperty('intervals') && CONFIG.provider.intervals.length) {\n        if (query.hasOwnProperty('intervals')) {\n          for (var field in query.intervals) {\n            // Check if both from and to exists.\n            // @TODO: Review - This can be flipped to avoid the \"empty\" if - continue does nothing :)\n            if (!(query.intervals[field].hasOwnProperty('from') && query.intervals[field].from !== '') &&\n                !(query.intervals[field].hasOwnProperty('to') && query.intervals[field].to !== '')) {\n              // Remove invalidated interval.\n              delete query.intervals[field];\n            }\n          }\n        }\n      }\n      else {\n        // Configuration does not have intervals.\n        if (query.hasOwnProperty('intervals')) {\n          delete query.intervals;\n        }\n      }\n\n      // Keep track of the current URL.\n      window.location.hash = encodeSearchQuery(query);\n\n      // Force search filters form configuration (predefined filters).\n      if (CONFIG.provider.hasOwnProperty('force') && CONFIG.provider.force.length) {\n        // If the query has been loaded form the URL, it may not have any\n        // selected filters, hence no filters on the query object.\n        if (!query.hasOwnProperty('filters')) {\n          query.filters = {};\n        }\n\n        var forces = CONFIG.provider.force;\n        for (var i in forces) {\n          var force = forces[i];\n          // Check if user have selected filter, if not init it.\n          if (!query.filters.hasOwnProperty(force.field)) {\n            query.filters[force.field] = {};\n          }\n\n          // Insert the forced field values.\n          for (var j in force.values) {\n            query.filters[force.field][force.values[j]] = true;\n          }\n        }\n      }\n\n      return provider.search(query);\n    };\n\n    /**\n     * Get filters provided by configuration.\n     *\n     * @returns json\n     */\n    this.getRawFilters = function getRawFilters() {\n      return provider.getRawFilters();\n    };\n\n    /**\n     * Get filters provided by search engine used.\n     *\n     * @returns json\n     */\n    this.getFilters = function getFilters() {\n      return provider.getFilters();\n    };\n  }\n]);\n","/**\n * @file\n * This is the main controller for the application.\n *\n * It controls the search box and filters.\n */\n\nangular.module('searchBoxApp').controller('boxController', ['CONFIG', 'communicatorService', 'searchProxyService', '$scope',\n  function (CONFIG, communicatorService, searchProxyService, $scope) {\n    'use strict';\n\n    /**\n     * Execute the search and emit the results.\n     */\n    function search() {\n      // Send info to restults that a new search have started.\n      communicatorService.$emit('searching', {});\n\n      // Start the search request.\n      searchProxyService.search($scope.query).then(\n        function (data) {\n          // Updated filters.\n          searchProxyService.getFilters().then(\n            function (filters) {\n              $scope.filters = filters;\n            },\n            function (reason) {\n              console.error(reason);\n            }\n          );\n\n          // Send results.\n          communicatorService.$emit('hits', {\"hits\": data});\n        },\n        function (reason) {\n          console.error(reason);\n        }\n      );\n    }\n\n    /**\n     * Initialize the controller and configure the basic scope.\n     */\n    function init() {\n      // Get state from previous search.\n      // @TODO: Review - should be called something else than init?: getState().\n      var state = searchProxyService.init();\n\n      // Get filters.\n      $scope.filters = state.filters;\n\n      // Set template to use.\n      $scope.template = CONFIG.templates.box;\n\n      // Init the query object.\n      $scope.query = {\n        'text': '',\n        'filters': {}\n      };\n\n      // Check if any intervals have been configured.\n      if (CONFIG.provider.hasOwnProperty('intervals')) {\n        $scope.intervals = CONFIG.provider.intervals;\n        $scope.query.intervals = {};\n      }\n\n      // Check if any dates have been configured.\n      if (CONFIG.provider.hasOwnProperty('dates')) {\n        $scope.dates = CONFIG.provider.dates;\n        $scope.query.dates = {};\n      }\n\n      // Check if any search query have been located from the hash tag.\n      if (state.hasOwnProperty('query')) {\n        // Query found in state, so execute that search.\n        $scope.query = state.query;\n        search();\n      }\n      else {\n        // Check if the provider supports an pager.\n        if (CONFIG.provider.hasOwnProperty('pager')) {\n          // Add pager information to the search query.\n          $scope.query.pager = angular.copy(CONFIG.provider.pager);\n        }\n\n        // Check if an inital search should be executed.\n        if (CONFIG.hasOwnProperty('initialQueryText')) {\n          $scope.query.text = angular.copy(CONFIG.initialQueryText);\n\n          // Execture the search.\n          search();\n        }\n        else {\n          // Get filters based on search content (maybe slow).\n          searchProxyServiceService.getFilters().then(\n            function (filters) {\n              $scope.filters = filters;\n            },\n            function (reason) {\n              console.error(reason);\n            }\n          );\n        }\n      }\n    }\n\n    /**\n     * Updated search based on pager.\n     */\n    function pagerUpdated(data) {\n      $scope.query.pager = {\n        'size': data.size,\n        'page': data.page\n      };\n      search();\n    }\n\n    /**\n     * Communication listener for pager changes from the search results\n     * application.\n     */\n    communicatorService.$on('pager', function (event, data) {\n      var phase = this.$root.$$phase;\n      if (phase === '$apply' || phase === '$digest') {\n        pagerUpdated(data);\n      }\n      else {\n        $scope.$apply(function () {\n          pagerUpdated(data);\n        });\n      }\n    });\n\n    /**\n     * Search click handler.\n     *\n     * Simple wrapper for search that resets the pager before executing the\n     * search.\n     */\n    $scope.searchClicked = function searchClicked() {\n      // Reset pager.\n      if ($scope.query.hasOwnProperty('pager')) {\n        $scope.query.pager = angular.copy(CONFIG.provider.pager);\n      }\n\n      search();\n    };\n\n    // Get the show on the road.\n    init();\n  }\n]);\n","/**\n * @file\n * This is the controller for the search result application.\n *\n * It simply updates the view when hits have been received.\n */\n\nangular.module('searchResultApp').controller('resultController', ['CONFIG', 'communicatorService', '$scope',\n  function (CONFIG, communicatorService, $scope) {\n    'use strict';\n\n    // Set template to use.\n    $scope.template = CONFIG.templates.result;\n\n    // Scope variable that can be used to make indications on the current\n    // process. E.g display spinner.\n    $scope.searching = false;\n\n    // Check if the provider supports an pager.\n    if (CONFIG.provider.hasOwnProperty('pager')) {\n      // Add pager information to the scope.\n      $scope.pager = angular.copy(CONFIG.provider.pager);\n    }\n\n    /**\n     * Update pager information.\n     */\n    $scope.search = function search() {\n      communicatorService.$emit('pager', $scope.pager);\n    };\n\n    /**\n     * Hanled search results hits from the search box application.\n     */\n    $scope.hits = [];\n    communicatorService.$on('hits', function onHits(event, data) {\n      var phase = this.$root.$$phase;\n      if (phase === '$apply' || phase === '$digest') {\n        $scope.hits = data.hits;\n        $scope.searching = false;\n      }\n      else {\n        $scope.$apply(function () {\n          $scope.hits = data.hits;\n          $scope.searching = false;\n        });\n      }\n    });\n\n    /**\n     * Hanled searching message, send when search is called.\n     */\n    communicatorService.$on('searching', function onSearching(event, data) {\n      var phase = this.$root.$$phase;\n      if (phase === '$apply' || phase === '$digest') {\n        $scope.searching = true;\n      }\n      else {\n        $scope.$apply(function () {\n          $scope.searching = true;\n        });\n      }\n    });\n\n    /**\n     * Handled pager updates.\n     */\n    communicatorService.$on('pager', function onPager(event, data) {\n      var phase = this.$root.$$phase;\n      if (phase === '$apply' || phase === '$digest') {\n        $scope.pager = data;\n      }\n      else {\n        $scope.$apply(function () {\n          $scope.pager = data;\n        });\n      }\n    });\n  }\n]);\n"],"sourceRoot":"/source/"}